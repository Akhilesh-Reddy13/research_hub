"""
LaTeX compiler utility.

Each workspace gets an isolated folder under  backend/latex-projects/{workspace_id}/
Compilation uses the free latex.ytotech.com online API (no local pdflatex needed).
Falls back to local pdflatex if available.
"""

import asyncio
import os
import re
import shutil
import subprocess
import uuid
from pathlib import Path

import httpx

# Root directory for all LaTeX projects
LATEX_PROJECTS_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), "latex-projects")
os.makedirs(LATEX_PROJECTS_DIR, exist_ok=True)

# Online LaTeX compilation API (free, no key needed)
LATEX_ONLINE_API = "https://latex.ytotech.com/builds/sync"

# Default starter template — includes sample content to verify it works
DEFAULT_TEMPLATE = r"""\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[margin=1in]{geometry}
\usepackage{xcolor}

\title{\textbf{Welcome to ResearchHub}}
\author{ResearchHub AI Platform}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This is a sample document generated by \textbf{ResearchHub's} integrated LaTeX editor.
If you can see this PDF, the compiler is working correctly!
You can now write, compile, and preview your research papers directly inside the platform.
\end{abstract}

\section{Introduction}
Welcome to the \textbf{ResearchHub LaTeX Editor} --- your personal Overleaf-like
environment built right into the research platform.

This editor supports:
\begin{itemize}
  \item Real-time code editing with syntax highlighting
  \item One-click PDF compilation
  \item Live PDF preview
  \item Multiple file support
  \item Template selection (Blank, IEEE, and more)
\end{itemize}

\section{Mathematics Demo}
Here is a famous equation to verify math rendering:

\begin{equation}
  E = mc^2
\end{equation}

And the quadratic formula:
\begin{equation}
  x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}
\end{equation}

A matrix example:
\[
  A = \begin{pmatrix}
    1 & 2 & 3 \\
    4 & 5 & 6 \\
    7 & 8 & 9
  \end{pmatrix}
\]

\section{Getting Started}
\begin{enumerate}
  \item Edit this document in the center panel
  \item Click \textcolor{green!60!black}{\textbf{Compile}} to generate your PDF
  \item View the result in the right panel
  \item Download your PDF when ready
\end{enumerate}

\section{Conclusion}
If you are reading this, your LaTeX compiler is working perfectly.
Happy writing!

\vspace{1cm}
\noindent\rule{\textwidth}{0.4pt}
\begin{center}
  \small\textit{Generated by ResearchHub AI --- Your Intelligent Research Companion}
\end{center}

\end{document}
"""

# IEEE template
IEEE_TEMPLATE = r"""\documentclass[conference]{IEEEtran}

\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{cite}

\title{Paper Title}
\author{
  \IEEEauthorblockN{First Author}
  \IEEEauthorblockA{Department \\ University \\ email@example.com}
  \and
  \IEEEauthorblockN{Second Author}
  \IEEEauthorblockA{Department \\ University \\ email@example.com}
}

\begin{document}

\maketitle

\begin{abstract}
This document is a template for IEEE conference papers.
\end{abstract}

\begin{IEEEkeywords}
keyword1, keyword2, keyword3
\end{IEEEkeywords}

\section{Introduction}
Your introduction here.

\section{Related Work}

\section{Methodology}

\section{Experiments}

\section{Results}

\section{Conclusion}

\bibliographystyle{IEEEtran}
% \bibliography{references}

\end{document}
"""

TEMPLATES = {
    "blank": DEFAULT_TEMPLATE,
    "ieee": IEEE_TEMPLATE,
}


def _workspace_dir(workspace_id: int) -> str:
    """Return (and create) the project directory for a workspace."""
    d = os.path.join(LATEX_PROJECTS_DIR, str(workspace_id))
    os.makedirs(d, exist_ok=True)
    return d


def _sanitize_filename(name: str) -> str:
    """Allow only safe filenames."""
    name = os.path.basename(name)
    name = re.sub(r"[^a-zA-Z0-9._\-]", "_", name)
    if not name:
        name = "file.tex"
    return name


# ────────────────────────────────────────────
# Public API
# ────────────────────────────────────────────

def get_file_tree(workspace_id: int) -> list[dict]:
    """Return a flat list of files in the workspace project folder."""
    root = _workspace_dir(workspace_id)
    tree = []
    for entry in sorted(Path(root).rglob("*")):
        if entry.is_file():
            rel = entry.relative_to(root).as_posix()
            # skip auxiliary build artefacts
            if any(rel.endswith(ext) for ext in (".aux", ".log", ".out", ".toc", ".synctex.gz", ".fls", ".fdb_latexmk")):
                continue
            tree.append({"name": rel, "type": "file"})
    return tree


def read_file(workspace_id: int, filename: str) -> str:
    """Read the contents of a file inside the workspace project."""
    root = _workspace_dir(workspace_id)
    safe = _sanitize_filename(filename)
    path = os.path.join(root, safe)
    if not os.path.isfile(path):
        # First time — create with default template
        if safe == "main.tex":
            write_file(workspace_id, safe, DEFAULT_TEMPLATE)
            return DEFAULT_TEMPLATE
        return ""
    with open(path, "r", encoding="utf-8") as f:
        return f.read()


def write_file(workspace_id: int, filename: str, content: str) -> str:
    """Write content to a file in the workspace project.  Returns the sanitized filename."""
    root = _workspace_dir(workspace_id)
    safe = _sanitize_filename(filename)
    path = os.path.join(root, safe)
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)
    return safe


def delete_file(workspace_id: int, filename: str) -> bool:
    root = _workspace_dir(workspace_id)
    safe = _sanitize_filename(filename)
    path = os.path.join(root, safe)
    if os.path.isfile(path) and safe != "main.tex":
        os.remove(path)
        return True
    return False


def _run_pdflatex_local(root: str, tex_path: str) -> dict:
    """Synchronous local pdflatex runner (called in a thread pool)."""
    logs = ""
    for run in range(2):
        try:
            result = subprocess.run(
                [
                    "pdflatex",
                    "-interaction=nonstopmode",
                    "-halt-on-error",
                    "-output-directory", root,
                    tex_path,
                ],
                cwd=root,
                capture_output=True,
                timeout=60,
            )
            logs = result.stdout.decode("utf-8", errors="replace")
            if result.stderr:
                logs += "\n" + result.stderr.decode("utf-8", errors="replace")

            if result.returncode != 0 and run == 0:
                return {"success": False, "pdf_path": None, "logs": logs}

        except subprocess.TimeoutExpired:
            return {"success": False, "pdf_path": None, "logs": "Compilation timed out (60 s)."}
        except FileNotFoundError:
            return None  # Signal: local pdflatex not available

    pdf_path = os.path.join(root, "main.pdf")
    if os.path.isfile(pdf_path):
        return {"success": True, "pdf_path": pdf_path, "logs": logs}

    return {"success": False, "pdf_path": None, "logs": logs}


async def _compile_online(root: str, tex_content: str) -> dict:
    """Compile LaTeX using the free online API (latex.ytotech.com)."""
    payload = {
        "compiler": "pdflatex",
        "resources": [
            {
                "main": True,
                "content": tex_content,
            }
        ],
    }

    try:
        async with httpx.AsyncClient(timeout=90) as client:
            resp = await client.post(LATEX_ONLINE_API, json=payload)

            if resp.status_code in (200, 201) and resp.headers.get("content-type", "").startswith("application/pdf"):
                pdf_path = os.path.join(root, "main.pdf")
                with open(pdf_path, "wb") as f:
                    f.write(resp.content)
                return {
                    "success": True,
                    "pdf_path": pdf_path,
                    "logs": "Compiled successfully via online LaTeX service.",
                }
            else:
                # API returned error text
                error_text = resp.text[:2000] if resp.text else f"HTTP {resp.status_code}"
                return {
                    "success": False,
                    "pdf_path": None,
                    "logs": f"Online compilation failed:\n{error_text}",
                }
    except httpx.TimeoutException:
        return {"success": False, "pdf_path": None, "logs": "Online compilation timed out (90 s)."}
    except Exception as e:
        return {"success": False, "pdf_path": None, "logs": f"Online compilation error: {str(e)}"}


async def compile_latex(workspace_id: int) -> dict:
    """
    Compile main.tex → main.pdf.
    Strategy: try local pdflatex first; if not installed, use online API.
    Returns {"success": bool, "pdf_path": str|None, "logs": str}
    """
    root = _workspace_dir(workspace_id)
    tex_path = os.path.join(root, "main.tex")

    if not os.path.isfile(tex_path):
        return {"success": False, "pdf_path": None, "logs": "main.tex not found."}

    # Try local pdflatex first
    loop = asyncio.get_event_loop()
    local_result = await loop.run_in_executor(None, _run_pdflatex_local, root, tex_path)
    if local_result is not None:
        return local_result

    # Local pdflatex not found — use online API
    with open(tex_path, "r", encoding="utf-8") as f:
        tex_content = f.read()

    return await _compile_online(root, tex_content)


def get_pdf_path(workspace_id: int) -> str | None:
    """Return the path to the compiled PDF, or None."""
    path = os.path.join(_workspace_dir(workspace_id), "main.pdf")
    return path if os.path.isfile(path) else None
